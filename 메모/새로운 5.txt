5/24	
ctrl + F12 구조보기
ctrl + alt + T 반복문 감싸기
alt + enter 오류찾기



5/25
인터페이스(inter+face)
ctrl + I 인터페이스구현
ctrl + H 계층구조

메소드 재정의(오버라이딩) 전제조건
1.메소드선언부가 동일(반환타입, 메소드이름, 매개변수(갯수,타입))
2.접근제한자는 동일하거나 가시범위가 넓어야한다.
3.인스턴스 메소드만 대상(private메소드 final은 제외)


1. public 	 : 어디서든 접근가능
2. protected : 동일 패키지 및 자식클래스에서만 접근가능
3. default(접근제한자를 명시하지 않는 경우): 동일 패키지면 접근가능
4. private 	 : 동일 클래스내에서만 접근가능



5/26
객체비교
1. 동일비교 .인스턴스의 실체가 같은지(주소비교) ==    Object.equals()
2. 동등비교 .인스턴스의 속성값이 값은지 (내용비교) equals를 재정의하기.

5. this.data == ((A)(obj).data)
result




예외처리방법
1.try~catch~finally
2 호출한 메소드로 예외를 위임



5/27
1. 예외처리란?
오류(error) : 개발자가 코드상으로 처리할 수 없는 오류 ex.시스템,네트워크,H/W장애
예외(exception) : 개발자가 코드상으로 처리 할 수 있는 오류
예외원인 : 프로그램 논리흐름상 필요에의해 의도적으로 예외를 발생, 개발자의 코드 작성에서 빚어진 실수
예외처리 목적 : 프로그램의 비정상적인 종료없이 정상적으로 작동하도록 하기위함

2. checked & unchecked  exception 차이점
 : checked 일반예외는 컴파일 시점에 처리하지않으면 실행자체가 불가능하다. RuntimeException을 상속하지않는 Exception
 : unchecked 실행예외는 실행 할 때 체크한다.  RuntimeException을 상속하는 Exception
	실행시 예외가 발생할 수 있다. 프로그래머의 역량에 의존적이다.
	예외발생시 예외를 처리하지않으면 자동으로 위임된다.
 
3. 예외처리 하는 방법 2가지? 
 : 직접처리 - try~catch~finally. 예외가 예상되는 코드를 감싸서 직접 처리
 : 예외전가 - throws. 호출한 메소드에게 예외처리를 위임 
 wasitacatisaw 
 
4. 오버로딩이란?
 : 입력매개변수의 개수나 자료형이 다른, 여러개의 동일한 이름을 지닌 메서드를 같은 공간에 정의하는 것.
 print(int), print(int, String), print(String) .....

5. 오버로딩의 성립 전제조건?
 : 메서드이름은 같아야한다. 매개변수(타입, 갯수, 순서)가 달라야한다.
 접근제한자는 상관없다.
 
 
6. 오버라이딩이란? @
 : 클래스간 상속 또는 인터페이스 구현클래스에서 상위개념의 메소드를 재정의하는 기술
 : 부모클래스에게 상속받은 메서드와 동일한 이름의 메서드를 재정의하는 것. 부모메서드를 자신이 만든 메서드로 덮어쓰는 개념.
 
7. 오버라이딩 성립조건
 : 부모클래스의 메서드와 시그니처(매서드명, 입력매개변수의 타입과 개수) 및 리턴타입(int 등)이 동일해야한다.
 : 부모클래스의 메소드보다 접근지정자의 범위가 넓거나 같아야한다.
 @override 성립조건이 만족하는지 체크
 
8. 생성자의 역할?
 : 인스턴스생성시 호출되어 인스턴스의 속성값을 초기화하는 역할
 : 클래스의 객체를 생성한다. 객체 내에 포함되는 필드의 초기화를 수행한다.
 ( 클래스명과 동일한 이름으로 지어야한다. 리턴타입이 없다.
   직접만들지 않으면 컴파일러가 입력매개변수가 없는 기본생성자를 자동으로 추가해준다.
   객체생성이후 할 일을 담는다.
   직접 생성자를 만들면 컴파일러가 기본생성자를 만들지 않는다.)

9. class란?
 : 개념(속성, 행위)를 정의하기위해 java언어에서 제공하는 문법
 : 다양한 자료형의 데이터를 하나로 묶어 관리하고 데이터를 처리하는 기능(메서드)까지 관리하는 문법요소.
 
 
 ------------------------
10. interface란? day12
 : 개념간의 상호작용을 표준화하기위해 java언어에서 제공하는 문법
 : 멤버의 접근제한자는 자동으로 (public)
 : 멤버필드는 상수(public static final) public static final int voltage = 220;
 : 멤버 메소드는 추상메소드(public abstract 생략가능)로 정의한다. public abstract void on();
 : class키워드 대신 interface키워드를 사용해 선언한다.
 : static, default - 유지보스측면에서 확장용도로 사용됨.
   static - Main에서만 (인터페이스.메소드이름)으로 사용할 수 있다.재정의불가
   default - 구현클래스에서 재정의가능. 클래스에 오버라이딩하지않아도 됨.
 :이외의 모든 메서드는 public abstract(자동으로 추가됨)로 정의된 객체지향 프로그래밍요소.
 
public static final int a = 3;
static이 붙어있기때문에 클래스명이나 인터페이스명으로 바로 접근 할 수 있다.
final이 붙어있기때문에 값을 다시 변경 할 수 없다.

1. 멤버필드는 상수(static final)만 올수 있다. 생략해도 자동 컴파일
2. 멤버메소드는 추상메소드가 온다. (메소드 선언부)호출이름, 입력, 출력
3. 모든 멤버는 public (public 키워드 명시 안해도 자동 public)
4. 인스턴스를 만들수 없다. 실체화 할 수 없다. 하지만 타입으로는 사용가능(구현체 대입)
5. 인터페이스 구현은 다중 구현이 가능
6. 인터페이스간의 상속은 단일상속.

인터페이스 -> 클래스로 오버라이딩 해야하는데 default는 나중에 추가할 때 영향주지않기위해서 사용.
default는 클래스에 오버라이딩 안돼있어도됨.
-------------------------------------



11. final 키워드의 3가지(변수, 클래스, 메소드) 쓰임?
 final + 클래스 - 최종개념으로 하위개념 올 수 없다. 더 이상 자식클래스가 없다. 상속자체가 불가능한 클래스.
 final + 메소드 - 최종메소드. 오버라이딩 불가능한 클래스. 상위개념의 메소드를 하위개념에서 재정의가 불가능하다.
 final + 변수  - 초기화 이후 재할당 불가능.


12. 반환문(return)의 용도
 : return - 메소드 내에서 실행을 종료후 호출한 곳으로 제어가 이동
 : return + 표현식(값,변수,식,메소드호출) 매소드 내에서 실행을 종료하고 호출한 메소드로 반환값을 넘겨준다.
 
13. 매개변수란?
매개변수(파라미터, 인수) : 메소드 선언부에서 메소드외부에서 입력받기위해 선언된 변수
				  메소드내에서 지역변수처럼 사용된다.
				  초기화는 메소드 호출될때 이뤄진다.

14. 지역변수란?
지역변수 : 메소드내에 선언된 변수
		초기화이후에 사용할 수 있다.
		초기화 - 변수가 선언된 이후 최초로 값을 할당하는 표현식
		생명주기는 블럭내에서만 유효.


15. 추상클래스란?
 abstract + class (미완성개념) :
 1. 인스턴스를 만들 수 없다. 실체화할 수 없다.
 2. 타입(개념)으로는 사용할 수 있다.
 3. abstract 메소드가 없어도 abstract키워드를 클래스에 사용가능
 4. abstract 메소드가가 하나라도 존재하는 클래스는 abstract클래스

 
16. 추상메소드란?
 abstract + method (미완성 메소드) :
 1. 메소드 선언부만 존재, 구현부 바디가 없다.
 2. abstract 메소드가 하나라도 존재하면 그 클래스는 abstract클래스여야한다.
 3. 인터페이스에서 

 
17. 접근제한자 4가지에 대해 설명하시오
 : 식별자(멤버필드, 멤버메소드, 생성자메소드, 클래스)의 가시범위를 나타낸다.
 모듈 > 패키지(상위.하위) > 클래스,인터페이스,열거형,예외,어노테이션
 public 	 : 어디서든 접근가능
 protected 	 : 동일 패키지 및 다른패키지에 존재하는 자식클래스
 default(접근제한자를 명시하지 않는 경우): 동일 패키지면 접근가능
 private 	 : 동일 클래스내에서만 접근가능
 
 import: 다른패키지에 있는 참조타입을 사용하고자할때는 import를 사용해야한다.(java.lang.* 는 생략가능)
 import 패키지명1.패키지명2...참조타입
 import 패키지명1.패기지명2...*
 
18. 인스턴스 멤버와 정적멤버의 차이점   (day 9)
인스턴스멤버 - (인스턴스)객체를 생성한 후에 사용할 수 있는 멤버. static이 붙어있지 않은 것
인스턴스멤버 메소드 바디에 인스턴스멤버, 정적멤버 사용 가능

정적멤버 - 객체의 생성 없이 (클래스명.멤버명)만으로 바로 사용할 수 있는것.
정적멤버메소드 안에 정적멤버만 사용가능

19. 익명클래스를 생성하는 2가지 방법
익명객체(인스턴스)는 단독으로 생성 불가능.
 : 클래스를 상속해서 생성   ex. new 클래스명(){ }
 : 인터페이스를 구현해서 생성 ex. new 인터페이스명(){ }  
생성자메소드 뒤에 중괄호를 넣어 생성. 중괄호부분

20. 익명클래스를 사용하는 이유?
1회성 객체 필요시 이름없는 클래스의 선언과 인스턴스화를 동시에 수행.
1회성 인스턴스를 만들어 편의를 위해 따로 클래스를 정의하지 않기 위해 


day 10 exam 1


ctrl + shift + J  = 라인합치기
ctrl + alt + V = 



